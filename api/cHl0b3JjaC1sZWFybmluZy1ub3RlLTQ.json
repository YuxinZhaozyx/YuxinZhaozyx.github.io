{"title":"[PyTorch学习笔记] Training A Classifier","date":"2019-07-23T09:40:02.000Z","thumbnail":"/static/image/pytorch.png","link":"pytorch-learning-note-4","comments":true,"tags":["pytorch"],"categories":["machine-learning"],"updated":"2022-01-04T08:35:48.627Z","content":"<p>本文是PyTorch官方教程 [DEEP LEARNING WITH PYTORCH: A 60 MINUTE BLITZ] Training A Classifier 的学习笔记</p>\n<a id=\"more\"></a>\n\n\n\n<p>一般情况下处理图像、文本、音频和视频数据时，可以使用标准的Python包来加载数据到一个numpy数组中。 然后把这个数组转换成 <code>torch.*Tensor</code>。</p>\n<ul>\n<li>图像可以使用 Pillow, OpenCV</li>\n<li>音频可以使用 scipy, librosa</li>\n<li>文本可以使用原始Python和Cython来加载，或者使用 NLTK或 SpaCy 处理</li>\n</ul>\n<p>特别的，对于图像任务，<code>torchvision</code> 包 包含了处理一些基本图像数据集的方法。这些数据集包括 Imagenet, CIFAR10, MNIST 等。除了数据加载以外，<code>torchvision</code> 还包含了图像转换器， <code>torchvision.datasets</code> 和 <code>torch.utils.data.DataLoader</code>。</p>\n<p><code>torchvision</code>包不仅提供了巨大的便利，也避免了代码的重复。</p>\n<p>以下使用的案例中，将使用CIFAR10数据集，它有如下10个类别 ：‘airplane’, ‘automobile’, ‘bird’, ‘cat’, ‘deer’, ‘dog’, ‘frog’, ‘horse’, ‘ship’, ‘truck’。CIFAR-10的图像都是 3x32x32大小的，即，3颜色通道，32x32像素。</p>\n<p><img src=\"pytorch-learning-note-4/68747470733a2f2f7079746f7263682e6f72672f7475746f7269616c732f5f696d616765732f636966617231302e706e67-1569997469002.png\" alt=\"img\" class=\"article-img\"></p>\n<h1 id=\"训练一个图像分类器\">训练一个图像分类器<a href=\"pytorch-learning-note-4#训练一个图像分类器\"></a></h1><p>依次按照下列顺序进行：</p>\n<ol>\n<li>使用<code>torchvision</code>加载和归一化CIFAR10训练集和测试集</li>\n<li>定义一个卷积神经网络</li>\n<li>定义损失函数</li>\n<li>在训练集上训练网络</li>\n<li>在测试集上测试网络</li>\n</ol>\n<h2 id=\"读取和归一化-CIFAR10\">读取和归一化 CIFAR10<a href=\"pytorch-learning-note-4#读取和归一化-CIFAR10\"></a></h2><p>使用<code>torchvision</code>可以非常容易地加载CIFAR10。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"><span class=\"keyword\">import</span> torchvision</span><br><span class=\"line\"><span class=\"keyword\">import</span> torchvision.transforms <span class=\"keyword\">as</span> transforms</span><br></pre></td></tr></table></div></figure>\n\n<p>torchvision的输出是[0,1]的PILImage图像，我们把它转换为归一化范围为[-1, 1]的张量。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transform = transforms.Compose(</span><br><span class=\"line\">    [transforms.ToTensor(),</span><br><span class=\"line\">     transforms.Normalize((<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>), (<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>))])</span><br><span class=\"line\"></span><br><span class=\"line\">trainset = torchvision.datasets.CIFAR10(root=<span class=\"string\">'./data'</span>, train=<span class=\"literal\">True</span>, download=<span class=\"literal\">True</span>, transform=transform)</span><br><span class=\"line\">trainloader = torch.utils.data.DataLoader(trainset, batch_size=<span class=\"number\">4</span>, shuffle=<span class=\"literal\">True</span>, num_workers=<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">testset = torchvision.datasets.CIFAR10(root=<span class=\"string\">'./data'</span>, train=<span class=\"literal\">False</span>, download=<span class=\"literal\">True</span>, transform=transform)</span><br><span class=\"line\">testloader = torch.utils.data.DataLoader(testset, batch_size=<span class=\"number\">4</span>, shuffle=<span class=\"literal\">False</span>, num_workers=<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">classes = (<span class=\"string\">'plane'</span>, <span class=\"string\">'car'</span>, <span class=\"string\">'bird'</span>, <span class=\"string\">'cat'</span>, <span class=\"string\">'deer'</span>, <span class=\"string\">'dog'</span>, <span class=\"string\">'frog'</span>, <span class=\"string\">'horse'</span>, <span class=\"string\">'ship'</span>, <span class=\"string\">'truck'</span>)</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"展示一些训练图像\">展示一些训练图像<a href=\"pytorch-learning-note-4#展示一些训练图像\"></a></h2><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt </span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 展示图像的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">imshow</span><span class=\"params\">(img)</span>:</span></span><br><span class=\"line\">    img = img / <span class=\"number\">2</span> + <span class=\"number\">0.5</span>  <span class=\"comment\"># unnormalize</span></span><br><span class=\"line\">    npimg = img.numpy()</span><br><span class=\"line\">    plt.imshow(np.transpose(npimg, (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>)))</span><br><span class=\"line\">    plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取随机数据</span></span><br><span class=\"line\">dataiter = iter(trainloader)</span><br><span class=\"line\">images, labels = dataiter.next()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 展示图像</span></span><br><span class=\"line\">imshow(torchvision.utils.make_grid(images))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示图像标签</span></span><br><span class=\"line\">print(<span class=\"string\">\" \"</span>.join(<span class=\"string\">\"%5s\"</span> % classes[labels[j]] <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>)))</span><br></pre></td></tr></table></div></figure>\n\n<p><img src=\"pytorch-learning-note-4/1563855333962-1569997468186.png\" alt=\"1563855333962\" class=\"article-img\"></p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">truck horse   dog  frog</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"定义一个卷积神经网络\">定义一个卷积神经网络<a href=\"pytorch-learning-note-4#定义一个卷积神经网络\"></a></h2><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> torch.nn <span class=\"keyword\">as</span> nn</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch.nn.functional <span class=\"keyword\">as</span> F </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Net</span><span class=\"params\">(nn.Module)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        super(Net, self).__init__()</span><br><span class=\"line\">        </span><br><span class=\"line\">        self.conv1 = nn.Conv2d(<span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>) <span class=\"comment\"># 3 input channels, 6 output channels, 5x5 convolutional kernel</span></span><br><span class=\"line\">        self.pool = nn.MaxPool2d(<span class=\"number\">2</span>, <span class=\"number\">2</span>)  <span class=\"comment\"># 池化层可以共用</span></span><br><span class=\"line\">        self.conv2 = nn.Conv2d(<span class=\"number\">6</span>, <span class=\"number\">16</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">        self.fc1 = nn.Linear(<span class=\"number\">16</span> * <span class=\"number\">5</span> * <span class=\"number\">5</span>, <span class=\"number\">120</span>)</span><br><span class=\"line\">        self.fc2 = nn.Linear(<span class=\"number\">120</span>, <span class=\"number\">84</span>)</span><br><span class=\"line\">        self.fc3 = nn.Linear(<span class=\"number\">84</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">forward</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        x = self.pool(F.relu(self.conv1(x)))</span><br><span class=\"line\">        x = self.pool(F.relu(self.conv2(x)))</span><br><span class=\"line\">        x = x.view(<span class=\"number\">-1</span>, <span class=\"number\">16</span> * <span class=\"number\">5</span> * <span class=\"number\">5</span>)</span><br><span class=\"line\">        x = F.relu(self.fc1(x))</span><br><span class=\"line\">        x = F.relu(self.fc2(x))</span><br><span class=\"line\">        x = self.fc3(x)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\">    </span><br><span class=\"line\">net = Net()</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"定义损失函数和优化器\">定义损失函数和优化器<a href=\"pytorch-learning-note-4#定义损失函数和优化器\"></a></h2><figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> torch.optim <span class=\"keyword\">as</span> optim</span><br><span class=\"line\"></span><br><span class=\"line\">criterion = nn.CrossEntropyLoss()</span><br><span class=\"line\">optimizer = optim.SGD(net.parameters(), lr=<span class=\"number\">0.001</span>, momentum=<span class=\"number\">0.9</span>)</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"训练网络\">训练网络<a href=\"pytorch-learning-note-4#训练网络\"></a></h2><p>我们只需在数据迭代器上循环，将数据输入给网络，并优化。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> epoch <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>):  <span class=\"comment\"># 多批次循环</span></span><br><span class=\"line\"></span><br><span class=\"line\">    running_loss = <span class=\"number\">0.0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, data <span class=\"keyword\">in</span> enumerate(trainloader, <span class=\"number\">0</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 获取输入</span></span><br><span class=\"line\">        inputs, labels = data</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 梯度置0</span></span><br><span class=\"line\">        optimizer.zero_grad()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 正向传播，反向传播，优化</span></span><br><span class=\"line\">        outputs = net(inputs)</span><br><span class=\"line\">        loss = criterion(outputs, labels)</span><br><span class=\"line\">        loss.backward()</span><br><span class=\"line\">        optimizer.step()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 打印状态信息</span></span><br><span class=\"line\">        running_loss += loss.item()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i % <span class=\"number\">2000</span> == <span class=\"number\">1999</span>: <span class=\"comment\"># 每2000批次打印一次</span></span><br><span class=\"line\">            print(<span class=\"string\">'[%d, %5d] loss: %.3f'</span> % (epoch + <span class=\"number\">1</span>, i + <span class=\"number\">1</span>, running_loss / <span class=\"number\">2000</span>))</span><br><span class=\"line\">            running_loss = <span class=\"number\">0.0</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">\"Finished Training\"</span>)</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"在测试集上测试网络\">在测试集上测试网络<a href=\"pytorch-learning-note-4#在测试集上测试网络\"></a></h2><p>我们在整个训练集上进行了2次训练，但是我们需要检查网络是否从数据集中学习到有用的东西。 通过预测神经网络输出的类别标签与实际情况标签进行对比来进行检测。 如果预测正确，我们把该样本添加到正确预测列表。 第一步，显示测试集中的图片并熟悉图片内容。然后用</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dataiter = iter(testloader)</span><br><span class=\"line\">images, labels = dataiter.next()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出是10个标签的能量。 一个类别的能量越大，神经网络越认为它是这个类别。所以让我们得到最高能量的标签。</span></span><br><span class=\"line\">outputs = net(images) </span><br><span class=\"line\">_, predicted = torch.max(outputs, <span class=\"number\">1</span>) <span class=\"comment\"># (maxvalues, indices) is returned</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示图片</span></span><br><span class=\"line\">imshow(torchvision.utils.make_grid(images))</span><br><span class=\"line\">print(<span class=\"string\">'GroundTruth: '</span>, <span class=\"string\">' '</span>.join(<span class=\"string\">'%5s'</span> % classes[labels[j]] <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>)))</span><br><span class=\"line\">print(<span class=\"string\">'Predicted:   '</span>, <span class=\"string\">' '</span>.join(<span class=\"string\">'%5s'</span> % classes[predicted[j]] <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>)))</span><br></pre></td></tr></table></div></figure>\n\n<p><img src=\"pytorch-learning-note-4/1563857966974-1569997468186.png\" alt=\"1563857966974\" class=\"article-img\"></p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GroundTruth:    cat  ship  ship plane</span><br><span class=\"line\">Predicted:     bird plane plane   dog</span><br></pre></td></tr></table></div></figure>\n\n<p>接下来让看看网络在整个测试集上的结果如何。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">correct = <span class=\"number\">0</span></span><br><span class=\"line\">total = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> torch.no_grad():</span><br><span class=\"line\">    <span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> testloader:</span><br><span class=\"line\">        images, labels = data</span><br><span class=\"line\">        outputs = net(images)</span><br><span class=\"line\">        _, predicted = torch.max(outputs.data, <span class=\"number\">1</span>)</span><br><span class=\"line\">        total += labels.size(<span class=\"number\">0</span>)</span><br><span class=\"line\">        correct += (predicted == labels).sum().item()</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'Accuracy of the network on the 10000 test images: %d %%'</span> % (<span class=\"number\">100</span> * correct / total))</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Accuracy of the network on the <span class=\"number\">10000</span> test images: <span class=\"number\">49</span> %</span><br></pre></td></tr></table></div></figure>\n\n<p>在识别哪一类的时候好，哪一类不好呢？</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class_correct = list(<span class=\"number\">0.</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>))</span><br><span class=\"line\">class_total = list(<span class=\"number\">0.</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>))</span><br><span class=\"line\"><span class=\"keyword\">with</span> torch.no_grad():</span><br><span class=\"line\">    <span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> testloader:</span><br><span class=\"line\">        images, labels = data</span><br><span class=\"line\">        outputs = net(images)</span><br><span class=\"line\">        _, predicted = torch.max(outputs, <span class=\"number\">1</span>)</span><br><span class=\"line\">        c = (predicted == labels).squeeze()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">            label = labels[i]</span><br><span class=\"line\">            class_correct[label] += c[i].item()</span><br><span class=\"line\">            class_total[label] += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">    print(<span class=\"string\">'Accuracy of %5s : %2d %%'</span> % (classes[i], <span class=\"number\">100</span> * class_correct[i] / class_total[i]))</span><br></pre></td></tr></table></div></figure>\n\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Accuracy of plane : <span class=\"number\">69</span> %</span><br><span class=\"line\">Accuracy of   car : <span class=\"number\">69</span> %</span><br><span class=\"line\">Accuracy of  bird : <span class=\"number\">15</span> %</span><br><span class=\"line\">Accuracy of   cat : <span class=\"number\">43</span> %</span><br><span class=\"line\">Accuracy of  deer : <span class=\"number\">44</span> %</span><br><span class=\"line\">Accuracy of   dog : <span class=\"number\">22</span> %</span><br><span class=\"line\">Accuracy of  frog : <span class=\"number\">72</span> %</span><br><span class=\"line\">Accuracy of horse : <span class=\"number\">58</span> %</span><br><span class=\"line\">Accuracy of  ship : <span class=\"number\">41</span> %</span><br><span class=\"line\">Accuracy of truck : <span class=\"number\">58</span> %</span><br></pre></td></tr></table></div></figure>\n\n<h2 id=\"在GPU上训练\">在GPU上训练<a href=\"pytorch-learning-note-4#在GPU上训练\"></a></h2><p>把一个神经网络移动到GPU上训练就像把一个Tensor转换GPU上一样简单。并且这个操作会递归遍历有所模块，并将其参数和缓冲区转换为CUDA张量。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">device = torch.device(<span class=\"string\">\"cuda:0\"</span> <span class=\"keyword\">if</span> torch.cuda.is_available() <span class=\"keyword\">else</span> <span class=\"string\">\"cpu\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 确认我们的电脑支持CUDA，然后显示CUDA信息</span></span><br><span class=\"line\">print(device)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将递归遍历所有模块并将模块的参数和缓冲区 转换成CUDA张量</span></span><br><span class=\"line\">net.to(device)</span><br></pre></td></tr></table></div></figure>\n\n<p>记住: <code>inputs</code> 和 <code>labels</code> 也要转换。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inputs, labels = inputs.to(device), labels.to(device)</span><br></pre></td></tr></table></div></figure>\n\n","prev":{"title":"[PyTorch学习笔记] Data Parallelism","link":"pytorch-learning-note-5"},"next":{"title":"[PyTorch学习笔记] Neural Networks","link":"pytorch-learning-note-3"},"plink":"https://yuxinzhao.net/pytorch-learning-note-4/","toc":[{"title":"训练一个图像分类器","id":"训练一个图像分类器","index":"1","children":[{"title":"读取和归一化 CIFAR10","id":"读取和归一化-CIFAR10","index":"1.1"},{"title":"展示一些训练图像","id":"展示一些训练图像","index":"1.2"},{"title":"定义一个卷积神经网络","id":"定义一个卷积神经网络","index":"1.3"},{"title":"定义损失函数和优化器","id":"定义损失函数和优化器","index":"1.4"},{"title":"训练网络","id":"训练网络","index":"1.5"},{"title":"在测试集上测试网络","id":"在测试集上测试网络","index":"1.6"},{"title":"在GPU上训练","id":"在GPU上训练","index":"1.7"}]}],"reward":true,"copyright":{"author":"Yuxin Zhao","link":"<a href=\"https://yuxinzhao.net/pytorch-learning-note-4/\" title=\"[PyTorch学习笔记] Training A Classifier\">https://yuxinzhao.net/pytorch-learning-note-4/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}