{"title":"python多进程及pytorch多GPU并行推断","date":"2020-02-28T20:30:16.000Z","thumbnail":"python-multi-gpu-multiprocessing/python.jpg","link":"python-multi-gpu-multiprocessing","comments":true,"tags":["multiprocessing","python","pytorch"],"categories":["machine-learning"],"updated":"2022-01-04T08:35:48.627Z","content":"<p>本文通过案例介绍我使用python自带的<code>multiprocessing</code>库进行多GPU并行推断的方案。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"阅前提示\">阅前提示<a href=\"python-multi-gpu-multiprocessing#阅前提示\"></a></h1><p>本文采用的方案已在Linux经过测试，但在Windows不可行，原因是Windows和Linux在多进程的实现上不同，Windows使用spawn模式，而Linux使用fork模式，这导致了Windows下使用<code>multiprocessing</code>存在着一些限制：</p>\n<ul>\n<li>必须保证传给 <code>Process.__init__()</code> 的所有参数均可pickle化。</li>\n<li>子进程访问父进程的全局变量时，得到的值并不能保证与父进程的全局变量相同(全局变量是模块级别除外)。</li>\n<li>必须确保在 <code>if __name__ == &#39;__main__&#39;:</code> 之后调用。</li>\n<li>更详细的说明见<a href=\"https://docs.python.org/2/library/multiprocessing.html?highlight=process#windows\" target=\"_blank\" rel=\"noopener\">此处</a>。</li>\n</ul>\n<p><strong>注：</strong>本文代码不能在Windows上运行，原因是违反第一项限制，虽然也有方法可以让它兼容Windows，但是目前我使用多进程的场景基本都在Linux上，<del>哪天有需要了再写个Windows兼容的版本</del>，<strong>兼容Windows的实现已完成，请参见<a href=\"/easycore-parallel-multi-gpu\">easycore多GPU并行加速</a></strong>。</p>\n<h1 id=\"设计思路\">设计思路<a href=\"python-multi-gpu-multiprocessing#设计思路\"></a></h1><p>我的方案是使用<strong>多生产者-单消费者模型</strong>。</p>\n<p>一个简单的解释：众多生产者们不断地往仓库中放入产品(过程耗时长)，而有一个消费者将仓库中的产品一件件地放到自己的车上，拿到一定数量后整辆车拉走。</p>\n<p>整体流程如下：</p>\n<ol>\n<li>将总任务拆分成多个可以并行的子任务。</li>\n<li>通知消费者需要从仓库中拿走的数量(即子任务的数量)。</li>\n<li>将子任务一项项加入任务队列，生产者只要看到任务队列有任务就会竞争这个任务。</li>\n<li>生产者执行完任务后，将产品(子任务的结果)放入仓库，消费者一看到仓库中有产品(子任务的结果)就会放到自己手上(对子任务的结果进行汇总和后处理)。</li>\n<li>主进程将所有子任务都加入任务队列后，就会等待消费者完成，从消费者处获得最终结果。</li>\n</ol>\n<p><img src=\"python-multi-gpu-multiprocessing/figure.png\" alt=\"figure\" class=\"article-img\"></p>\n<h1 id=\"案例\">案例<a href=\"python-multi-gpu-multiprocessing#案例\"></a></h1><h2 id=\"无序并行：求列表元素平方和\">无序并行：求列表元素平方和<a href=\"python-multi-gpu-multiprocessing#无序并行：求列表元素平方和\"></a></h2><p>我们先从一个简单的案例开始：求列表元素平方和。简单的案例更容易理解。</p>\n<p>我们将这个任务分成两部分：一个是对单个元素求平方，一个是将平方后的所有值相加。前者只需要部分数据，可独立运行，我们将这个任务分给生产者<code>Sumer._TaskWorker</code>；后者需要汇总所有前者生成的所有数据，我们将其分配给消费者<code>Sumer._ReceiveWorker</code>。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> multiprocessing <span class=\"keyword\">as</span> mp</span><br><span class=\"line\"><span class=\"keyword\">import</span> atexit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sumer</span>:</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_StopToken</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_TaskWorker</span><span class=\"params\">(mp.Process)</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, input_queue, output_queue)</span>:</span></span><br><span class=\"line\">            super(Sumer._TaskWorker, self).__init__()</span><br><span class=\"line\">            self.input_queue = input_queue    <span class=\"comment\"># the queue to get task</span></span><br><span class=\"line\">            self.output_queue = output_queue  <span class=\"comment\"># the queue to put result</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">            <span class=\"comment\"># initialization</span></span><br><span class=\"line\">            <span class=\"comment\"># anything</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># loop to get and do the tasks</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">                task = self.input_queue.get()  <span class=\"comment\"># pick a task from the queue</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> isinstance(task, Sumer._StopToken):  <span class=\"comment\"># `_StopToken` is a signal to stop this worker</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\"># decode task, it can be anything you defined.</span></span><br><span class=\"line\">                num = task  </span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\"># do the task. it's to get the suquare of the `num` here.</span></span><br><span class=\"line\">                result = num * num</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\"># put the result into the queue</span></span><br><span class=\"line\">                self.output_queue.put(result)  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_ReceiveWorker</span><span class=\"params\">(mp.Process)</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, receive_func, input_queue, output_queue)</span>:</span></span><br><span class=\"line\">            super(Sumer._ReceiveWorker, self).__init__()</span><br><span class=\"line\">            self.receive_func = receive_func  <span class=\"comment\"># the function to get the result from '_TaskWorker'</span></span><br><span class=\"line\">            self.input_queue = input_queue  </span><br><span class=\"line\">            self.output_queue = output_queue</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">                task = self.input_queue.get()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> isinstance(task, Sumer._StopToken):</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\"># decode task, get the number of tasks the worker will collect</span></span><br><span class=\"line\">                length = task</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\"># collect and postprocess the result from `_TaskWorker`</span></span><br><span class=\"line\">                sum = <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(length):</span><br><span class=\"line\">                    <span class=\"comment\"># collect data</span></span><br><span class=\"line\">                    data = self.receive_func()</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"comment\"># postprocess data. </span></span><br><span class=\"line\">                    sum += data</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\"># put the final result into the queue</span></span><br><span class=\"line\">                task = self.output_queue.put(sum)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, num_proc)</span>:</span></span><br><span class=\"line\">        self.num_proc = num_proc  <span class=\"comment\"># number of process</span></span><br><span class=\"line\"></span><br><span class=\"line\">        self.task_worker_input_queue = mp.Queue(maxsize=self.num_proc * <span class=\"number\">3</span>)</span><br><span class=\"line\">        self.task_worker_output_queue = mp.Queue(maxsize=self.num_proc * <span class=\"number\">3</span>)</span><br><span class=\"line\">        self.receive_worker_input_queue = mp.Queue(maxsize=<span class=\"number\">1</span>)</span><br><span class=\"line\">        self.receive_worker_output_queue = mp.Queue(maxsize=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># create workers</span></span><br><span class=\"line\">        self.task_workers = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(self.num_proc):</span><br><span class=\"line\">            self.task_workers.append(Sumer._TaskWorker(self.task_worker_input_queue, self.task_worker_output_queue))</span><br><span class=\"line\"></span><br><span class=\"line\">        self.receive_worker = Sumer._ReceiveWorker(self.get_from_task_worker, self.receive_worker_input_queue, self.receive_worker_output_queue)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># start workers</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> worker <span class=\"keyword\">in</span> self.task_workers:</span><br><span class=\"line\">            worker.start()</span><br><span class=\"line\">        self.receive_worker.start()</span><br><span class=\"line\"></span><br><span class=\"line\">        atexit.register(self.shutdown)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__del__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.shutdown()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shutdown</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(self.num_proc):</span><br><span class=\"line\">            self.put_into_task_worker(Sumer._StopToken())</span><br><span class=\"line\">        self.put_into_receive_worker(Sumer._StopToken())</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">put_into_task_worker</span><span class=\"params\">(self, data)</span>:</span></span><br><span class=\"line\">        self.task_worker_input_queue.put(data)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_from_task_worker</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.task_worker_output_queue.get()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">put_into_receive_worker</span><span class=\"params\">(self, data)</span>:</span></span><br><span class=\"line\">        self.receive_worker_input_queue.put(data)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_from_receive_worker</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.receive_worker_output_queue.get()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(self, data_list)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        Args:</span></span><br><span class=\"line\"><span class=\"string\">            data_list (list[float]):</span></span><br><span class=\"line\"><span class=\"string\">        </span></span><br><span class=\"line\"><span class=\"string\">        Returns:</span></span><br><span class=\"line\"><span class=\"string\">            float: sum of squares</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"comment\"># inform the receive worker the number of data to receive</span></span><br><span class=\"line\">        self.put_into_receive_worker(len(data_list))</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># put data to task worker</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> data_list:</span><br><span class=\"line\">            self.put_into_task_worker(data)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># get result from receive worker</span></span><br><span class=\"line\">        result = self.get_from_receive_worker()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    num_proc = <span class=\"number\">3</span></span><br><span class=\"line\">    sumer = Sumer(num_proc)</span><br><span class=\"line\">    </span><br><span class=\"line\">    data_list = list(range(<span class=\"number\">1000</span>))</span><br><span class=\"line\">    result = sumer(data_list)</span><br><span class=\"line\"></span><br><span class=\"line\">    print(result)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">del</span> sumer  <span class=\"comment\"># delete the object to remove process manually, otherwise these process will be auto closed when the program exits.</span></span><br></pre></td></tr></table></div></figure>\n\n<p><strong>注：</strong></p>\n<ul>\n<li>最后的 <code>del</code> 通过删除该对象可以手动关闭开的所有子进程，如果没有手动<code>del</code>的话，所有子进程直到主进程结束时才会自动关闭。</li>\n<li><strong>传入的数据不能过多</strong>，多少合适呢？只要保证消费者对象<code>Sumer._ReceiveWorker</code>放到输出队列的结果别太大就行，这是因为python进程间的通信使用的是pickle序列化对象，而pickle限制了最大只能序列化4GB的对象。<strong>PS: <a href=\"/easycore-parallel-multi-gpu\">easycore已克服该缺点</a></strong>。</li>\n</ul>\n<h2 id=\"有序并行：求列表元素平方\">有序并行：求列表元素平方<a href=\"python-multi-gpu-multiprocessing#有序并行：求列表元素平方\"></a></h2><p>上个案例介绍了求列表元素平方和的案例，但在这过程中，每个生产者处理子任务的速度不能保证相同，所以时常会出现先接到任务的生成者后完成的情况，这种情况下，消费者从仓库中拿出产品的顺序就乱了，对于”求列表元素平方和“这一案例，顺序改变并没有影响，但对于部分任务，就必须要保证消费者处理的顺序。</p>\n<p>接下来通过一个看似更简单的案例：求列表元素平方，我们来实现对数据的有序接收。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> multiprocessing <span class=\"keyword\">as</span> mp</span><br><span class=\"line\"><span class=\"keyword\">import</span> atexit</span><br><span class=\"line\"><span class=\"keyword\">import</span> bisect</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Squarer</span>:</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_StopToken</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_TaskWorker</span><span class=\"params\">(mp.Process)</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, input_queue, output_queue)</span>:</span></span><br><span class=\"line\">            super(Squarer._TaskWorker, self).__init__()</span><br><span class=\"line\">            self.input_queue = input_queue    <span class=\"comment\"># the queue to get task</span></span><br><span class=\"line\">            self.output_queue = output_queue  <span class=\"comment\"># the queue to put result</span></span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">            <span class=\"comment\"># initialization</span></span><br><span class=\"line\">            <span class=\"comment\"># anything</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># loop to get and do the tasks</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">                task = self.input_queue.get()  <span class=\"comment\"># pick a task from the queue</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> isinstance(task, Squarer._StopToken):  <span class=\"comment\"># `_StopToken` is a signal to stop this worker</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\"># decode task, it can be anything you defined.</span></span><br><span class=\"line\">                task_id, num = task  </span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\"># do the task. it's to get the suquare of the `num` here.</span></span><br><span class=\"line\">                result = num * num</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\"># put the result into the queue</span></span><br><span class=\"line\">                self.output_queue.put((task_id, result))  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_ReceiveWorker</span><span class=\"params\">(mp.Process)</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, receive_func, input_queue, output_queue)</span>:</span></span><br><span class=\"line\">            super(Squarer._ReceiveWorker, self).__init__()</span><br><span class=\"line\">            self.receive_func = receive_func  <span class=\"comment\"># the function to get the result from '_TaskWorker'</span></span><br><span class=\"line\">            self.input_queue = input_queue  </span><br><span class=\"line\">            self.output_queue = output_queue</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">                task = self.input_queue.get()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> isinstance(task, Squarer._StopToken):</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\"># decode task, get the number of tasks the worker will collect</span></span><br><span class=\"line\">                length = task</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\"># collect and postprocess the result from `_TaskWorker`</span></span><br><span class=\"line\">                data_list = []</span><br><span class=\"line\">                <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(length):</span><br><span class=\"line\">                    <span class=\"comment\"># collect data</span></span><br><span class=\"line\">                    data = self.receive_func()</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"comment\"># postprocess data. </span></span><br><span class=\"line\">                    data_list.append(data)</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\"># put the final result into the queue</span></span><br><span class=\"line\">                task = self.output_queue.put(data_list)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, num_proc)</span>:</span></span><br><span class=\"line\">        self.num_proc = num_proc  <span class=\"comment\"># number of process</span></span><br><span class=\"line\"></span><br><span class=\"line\">        self.put_id = <span class=\"number\">0</span></span><br><span class=\"line\">        self.get_id = <span class=\"number\">0</span></span><br><span class=\"line\">        self.id_buffer = []</span><br><span class=\"line\">        self.data_buffer = []</span><br><span class=\"line\"></span><br><span class=\"line\">        self.task_worker_input_queue = mp.Queue(maxsize=self.num_proc * <span class=\"number\">3</span>)</span><br><span class=\"line\">        self.task_worker_output_queue = mp.Queue(maxsize=self.num_proc * <span class=\"number\">3</span>)</span><br><span class=\"line\">        self.receive_worker_input_queue = mp.Queue(maxsize=<span class=\"number\">1</span>)</span><br><span class=\"line\">        self.receive_worker_output_queue = mp.Queue(maxsize=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># create workers</span></span><br><span class=\"line\">        self.task_workers = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(self.num_proc):</span><br><span class=\"line\">            self.task_workers.append(Squarer._TaskWorker(self.task_worker_input_queue, self.task_worker_output_queue))</span><br><span class=\"line\"></span><br><span class=\"line\">        self.receive_worker = Squarer._ReceiveWorker(self.get_from_task_worker, self.receive_worker_input_queue, self.receive_worker_output_queue)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># start workers</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> worker <span class=\"keyword\">in</span> self.task_workers:</span><br><span class=\"line\">            worker.start()</span><br><span class=\"line\">        self.receive_worker.start()</span><br><span class=\"line\"></span><br><span class=\"line\">        atexit.register(self.shutdown)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__del__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.shutdown()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shutdown</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(self.num_proc):</span><br><span class=\"line\">            self.task_worker_input_queue.put(Squarer._StopToken())</span><br><span class=\"line\">        self.receive_worker_input_queue.put(Squarer._StopToken())</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">put_into_task_worker</span><span class=\"params\">(self, data)</span>:</span></span><br><span class=\"line\">        task_id = self.put_id</span><br><span class=\"line\">        self.put_id += <span class=\"number\">1</span></span><br><span class=\"line\">        self.task_worker_input_queue.put((task_id, data))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_from_task_worker</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(self.id_buffer) <span class=\"keyword\">and</span> self.id_buffer[<span class=\"number\">0</span>] == self.get_id:</span><br><span class=\"line\">            data = self.data_buffer[<span class=\"number\">0</span>]</span><br><span class=\"line\">            <span class=\"keyword\">del</span> self.id_buffer[<span class=\"number\">0</span>], self.data_buffer[<span class=\"number\">0</span>]</span><br><span class=\"line\">            self.get_id += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> data</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">            task_id, data = self.task_worker_output_queue.get()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> task_id == self.get_id:</span><br><span class=\"line\">                self.get_id += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> data</span><br><span class=\"line\">            insert_position = bisect.bisect(self.id_buffer, task_id)</span><br><span class=\"line\">            self.id_buffer.insert(insert_position, task_id)</span><br><span class=\"line\">            self.data_buffer.insert(insert_position, data)</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">put_into_receive_worker</span><span class=\"params\">(self, data)</span>:</span></span><br><span class=\"line\">        self.receive_worker_input_queue.put(data)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_from_receive_worker</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.receive_worker_output_queue.get()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(self, data_list)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        Args:</span></span><br><span class=\"line\"><span class=\"string\">            data_list (list[float]):</span></span><br><span class=\"line\"><span class=\"string\">        </span></span><br><span class=\"line\"><span class=\"string\">        Returns:</span></span><br><span class=\"line\"><span class=\"string\">            list[float]: list of square of the data</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"comment\"># inform the receive worker the number of data to receive</span></span><br><span class=\"line\">        self.put_into_receive_worker(len(data_list))</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># put data to task worker</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> data_list:</span><br><span class=\"line\">            self.put_into_task_worker(data)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># get result from receive worker</span></span><br><span class=\"line\">        result = self.get_from_receive_worker()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    num_proc = <span class=\"number\">3</span></span><br><span class=\"line\">    squarer = Squarer(num_proc)</span><br><span class=\"line\">    </span><br><span class=\"line\">    data_list = list(range(<span class=\"number\">100</span>))</span><br><span class=\"line\">    result = squarer(data_list)</span><br><span class=\"line\"></span><br><span class=\"line\">    print(result)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">del</span> squarer  <span class=\"comment\"># delete the object to remove process manually, otherwise these process will be auto closed when the program exits.</span></span><br></pre></td></tr></table></div></figure>\n\n<p><strong>注：</strong></p>\n<ul>\n<li>上述代码主要修改了<code>Squarer.get_from_task_worker</code>部分，使其获取到的结果不是当前想要的下一个结果时，先将该结果缓存起来，直到获取到想要的结果，后续需要该结果时就可以直接从缓存中将其取出。这样的好处是不会导致生产者的输出队列积累过多结果导致死锁。</li>\n</ul>\n<h2 id=\"多GPU并行：推断\">多GPU并行：推断<a href=\"python-multi-gpu-multiprocessing#多GPU并行：推断\"></a></h2><p>以前面有序并行的案例为蓝本，我们来实现将pytorch模型并行到多个gpu上。</p>\n<p>首先我们先来设计一个简单的模型：</p>\n<figure class=\"highlight\"><figcaption><span>network.py</span></figcaption><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch.nn <span class=\"keyword\">as</span> nn</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch.nn.functional <span class=\"keyword\">as</span> F</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Net</span><span class=\"params\">(nn.Module)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        super(Net, self).__init__()</span><br><span class=\"line\">        self.fc = nn.Linear(<span class=\"number\">1</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">forward</span><span class=\"params\">(self, x)</span>:</span></span><br><span class=\"line\">        x = self.fc(x)</span><br><span class=\"line\">        x = F.relu(x)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br></pre></td></tr></table></div></figure>\n\n<p>接下来将网络并行到多个设备上：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> torch.multiprocessing <span class=\"keyword\">as</span> mp</span><br><span class=\"line\"><span class=\"keyword\">import</span> atexit</span><br><span class=\"line\"><span class=\"keyword\">import</span> bisect</span><br><span class=\"line\"><span class=\"keyword\">from</span> network <span class=\"keyword\">import</span> Net</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Predictor</span>:</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_StopToken</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_TaskWorker</span><span class=\"params\">(mp.Process)</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, input_queue, output_queue, device)</span>:</span></span><br><span class=\"line\">            super(Predictor._TaskWorker, self).__init__()</span><br><span class=\"line\">            self.input_queue = input_queue    <span class=\"comment\"># the queue to get task</span></span><br><span class=\"line\">            self.output_queue = output_queue  <span class=\"comment\"># the queue to put result</span></span><br><span class=\"line\">            self.device = device</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">            <span class=\"comment\"># initialization</span></span><br><span class=\"line\">            model = Net()</span><br><span class=\"line\">            model.to(self.device)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># loop to get and do the tasks</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">                task = self.input_queue.get()  <span class=\"comment\"># pick a task from the queue</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> isinstance(task, Predictor._StopToken):  <span class=\"comment\"># `_StopToken` is a signal to stop this worker</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\"># decode task, it can be anything you defined.</span></span><br><span class=\"line\">                task_id, x = task  </span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">with</span> torch.no_grad():</span><br><span class=\"line\">                    <span class=\"comment\"># do the task</span></span><br><span class=\"line\">                    x = x.to(self.device)</span><br><span class=\"line\">                    output = model(x)</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"comment\"># put the result into the queue</span></span><br><span class=\"line\">                    output = output.cpu()  <span class=\"comment\"># copy to cpu before send to another process</span></span><br><span class=\"line\">                self.output_queue.put((task_id, output))  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_ReceiveWorker</span><span class=\"params\">(mp.Process)</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, receive_func, input_queue, output_queue)</span>:</span></span><br><span class=\"line\">            super(Predictor._ReceiveWorker, self).__init__()</span><br><span class=\"line\">            self.receive_func = receive_func  <span class=\"comment\"># the function to get the result from '_TaskWorker'</span></span><br><span class=\"line\">            self.input_queue = input_queue  </span><br><span class=\"line\">            self.output_queue = output_queue</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">                task = self.input_queue.get()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> isinstance(task, Predictor._StopToken):</span><br><span class=\"line\">                    <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\"># decode task, get the number of tasks the worker will collect</span></span><br><span class=\"line\">                length = task</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\"># collect and postprocess the result from `_TaskWorker`</span></span><br><span class=\"line\">                data_list = []</span><br><span class=\"line\">                <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(length):</span><br><span class=\"line\">                    <span class=\"comment\"># collect data</span></span><br><span class=\"line\">                    data = self.receive_func()</span><br><span class=\"line\">                    </span><br><span class=\"line\">                    <span class=\"comment\"># postprocess data. </span></span><br><span class=\"line\">                    data_list.append(data)</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\"># put the final result into the queue</span></span><br><span class=\"line\">                data = torch.cat(data_list, dim=<span class=\"number\">0</span>)</span><br><span class=\"line\">                task = self.output_queue.put(data)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, device_list)</span>:</span></span><br><span class=\"line\">        self.num_proc = len(device_list)  <span class=\"comment\"># number of process</span></span><br><span class=\"line\"></span><br><span class=\"line\">        self.put_id = <span class=\"number\">0</span></span><br><span class=\"line\">        self.get_id = <span class=\"number\">0</span></span><br><span class=\"line\">        self.id_buffer = []</span><br><span class=\"line\">        self.data_buffer = []</span><br><span class=\"line\"></span><br><span class=\"line\">        self.task_worker_input_queue = mp.Queue(maxsize=self.num_proc * <span class=\"number\">3</span>)</span><br><span class=\"line\">        self.task_worker_output_queue = mp.Queue(maxsize=self.num_proc * <span class=\"number\">3</span>)</span><br><span class=\"line\">        self.receive_worker_input_queue = mp.Queue(maxsize=<span class=\"number\">1</span>)</span><br><span class=\"line\">        self.receive_worker_output_queue = mp.Queue(maxsize=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># create workers</span></span><br><span class=\"line\">        self.task_workers = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> device <span class=\"keyword\">in</span> device_list:</span><br><span class=\"line\">            self.task_workers.append(Predictor._TaskWorker(self.task_worker_input_queue, self.task_worker_output_queue, device))</span><br><span class=\"line\"></span><br><span class=\"line\">        self.receive_worker = Predictor._ReceiveWorker(self.get_from_task_worker, self.receive_worker_input_queue, self.receive_worker_output_queue)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># start workers</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> worker <span class=\"keyword\">in</span> self.task_workers:</span><br><span class=\"line\">            worker.start()</span><br><span class=\"line\">        self.receive_worker.start()</span><br><span class=\"line\"></span><br><span class=\"line\">        atexit.register(self.shutdown)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__del__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.shutdown()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shutdown</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(self.num_proc):</span><br><span class=\"line\">            self.task_worker_input_queue.put(Predictor._StopToken())</span><br><span class=\"line\">        self.receive_worker_input_queue.put(Predictor._StopToken())</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">put_into_task_worker</span><span class=\"params\">(self, data)</span>:</span></span><br><span class=\"line\">        task_id = self.put_id</span><br><span class=\"line\">        self.put_id += <span class=\"number\">1</span></span><br><span class=\"line\">        self.task_worker_input_queue.put((task_id, data))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_from_task_worker</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(self.id_buffer) <span class=\"keyword\">and</span> self.id_buffer[<span class=\"number\">0</span>] == self.get_id:</span><br><span class=\"line\">            data = self.data_buffer[<span class=\"number\">0</span>]</span><br><span class=\"line\">            <span class=\"keyword\">del</span> self.id_buffer[<span class=\"number\">0</span>], self.data_buffer[<span class=\"number\">0</span>]</span><br><span class=\"line\">            self.get_id += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> data</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">            task_id, data = self.task_worker_output_queue.get()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> task_id == self.get_id:</span><br><span class=\"line\">                self.get_id += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> data</span><br><span class=\"line\">            insert_position = bisect.bisect(self.id_buffer, task_id)</span><br><span class=\"line\">            self.id_buffer.insert(insert_position, task_id)</span><br><span class=\"line\">            self.data_buffer.insert(insert_position, data)</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">put_into_receive_worker</span><span class=\"params\">(self, data)</span>:</span></span><br><span class=\"line\">        self.receive_worker_input_queue.put(data)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_from_receive_worker</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.receive_worker_output_queue.get()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(self, data_list)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        Args:</span></span><br><span class=\"line\"><span class=\"string\">            data_list (list[float]): input data list</span></span><br><span class=\"line\"><span class=\"string\">        </span></span><br><span class=\"line\"><span class=\"string\">        Returns:</span></span><br><span class=\"line\"><span class=\"string\">            torch.FloatTensor:</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"comment\"># inform the receive worker the number of data to receive</span></span><br><span class=\"line\">        self.put_into_receive_worker(len(data_list))</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># put data to task worker</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> data <span class=\"keyword\">in</span> data_list:</span><br><span class=\"line\">            data = torch.Tensor([[data]])  <span class=\"comment\"># preprocess data</span></span><br><span class=\"line\">            self.put_into_task_worker(data)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># get result from receive worker</span></span><br><span class=\"line\">        result = self.get_from_receive_worker()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    device_list = [<span class=\"string\">\"cuda:0\"</span>, <span class=\"string\">\"cuda:1\"</span>, <span class=\"string\">\"cuda:2\"</span>, <span class=\"string\">\"cuda:3\"</span>]</span><br><span class=\"line\">    predictor = Predictor(device_list)</span><br><span class=\"line\">    </span><br><span class=\"line\">    data_list = list(range(<span class=\"number\">100</span>))</span><br><span class=\"line\">    result = predictor(data_list)</span><br><span class=\"line\"></span><br><span class=\"line\">    print(result.shape)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">del</span> predictor  <span class=\"comment\"># delete the object to remove process manually, otherwise these process will be auto closed when the program exits.</span></span><br></pre></td></tr></table></div></figure>\n\n<p><strong>注：</strong></p>\n<ul>\n<li>首先，这里将python自带的<code>multiprocessing</code>库替换成了<code>torch.multiprocessing</code>，这是因为pytorch官方对<code>multiprocessing</code>做了一层封装，使得不同进程之间可以共享<code>Tensor</code>，完全兼容<code>multiprocessing</code>的接口。本例中将<code>torch.multiprocessing</code>替换回<code>multiprocessing</code>并无影响。</li>\n<li>生产者<code>Predictor._TaskWorker</code>在将结果放进输出队列之前，最好将结果从GPU移到CPU(实际上是内存)，以避免GPU上的<code>Tensor</code>在不同进程间移动。</li>\n<li>通过<code>device_list = [&quot;cuda:0&quot;, &quot;cuda:1&quot;]</code> 可以指定多个GPU，而使用<code>device_list = [&quot;cpu&quot;, &quot;cpu&quot;]</code>还可以实现<strong>多CPU并行</strong> (在有多个CPU的情况下，系统会自动将进程分配给不同的CPU)，当然也可以混合使用CPU和GPU: <code>device_list = [&quot;cpu&quot;, &quot;cuda:0&quot;]</code>。</li>\n</ul>\n","prev":{"title":"发布第一个python包到PyPI","link":"publish-first-python-package-to-pypi"},"next":{"title":"使用manim制作数学动画","link":"manim"},"plink":"https://yuxinzhao.net/python-multi-gpu-multiprocessing/","toc":[{"title":"阅前提示","id":"阅前提示","index":"1"},{"title":"设计思路","id":"设计思路","index":"2"},{"title":"案例","id":"案例","index":"3","children":[{"title":"无序并行：求列表元素平方和","id":"无序并行：求列表元素平方和","index":"3.1"},{"title":"有序并行：求列表元素平方","id":"有序并行：求列表元素平方","index":"3.2"},{"title":"多GPU并行：推断","id":"多GPU并行：推断","index":"3.3"}]}],"reward":true,"copyright":{"author":"Yuxin Zhao","link":"<a href=\"https://yuxinzhao.net/python-multi-gpu-multiprocessing/\" title=\"python多进程及pytorch多GPU并行推断\">https://yuxinzhao.net/python-multi-gpu-multiprocessing/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}